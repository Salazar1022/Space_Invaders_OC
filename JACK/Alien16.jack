/** Alien de 16x16 en coordenadas de píxeles - OPTIMIZADO */
class Alien16 {
    field int x;
    field int y;
    field Array sprite;
    field boolean alive;
    field int points;
    
    constructor Alien16 new(int xPos, int yStart, Array spr, int pts) {
        let x = xPos;
        let y = yStart;
        let sprite = spr;
        let alive = true;
        let points = pts;
        return this;
    }
    
    /** OPTIMIZADO: Primero borra área, luego dibuja solo píxeles negros */
    method void draw() {
        var int x2; var int y2;
        var int row; var int bits; var int bit; var int px;
        var int drawX; var int drawY;
        
        let x2 = x + 31;
        let y2 = y + 31;
        
        // Validación estricta de límites
        if (x < 0) { return; }
        if (y < 0) { return; }
        if (x2 > 511) { return; }
        if (y2 > 255) { return; }
        if (x > x2) { return; }
        if (y > y2) { return; }
        
        // OPTIMIZACIÓN 1: Borrar toda el área de una vez
        do Screen.setColor(false);
        do Screen.drawRectangle(x, y, x2, y2);
        
        // OPTIMIZACIÓN 2: Solo dibujar píxeles activos
        do Screen.setColor(true);
        let row = 0;
        while (row < 16) {
            let bits = sprite[row];
            let bit = 0;
            while (bit < 16) {
                let px = bits & 1;
                if (px = 1) {
                    let drawX = x + ((15 - bit) * 2);
                    let drawY = y + (row * 2);
                    // OPTIMIZACIÓN 3: drawLine es más rápido que 4 drawPixel
                    do Screen.drawRectangle(drawX, drawY, drawX + 1, drawY + 1);
                }
                let bits = bits / 2;
                let bit = bit + 1;
            }
            let row = row + 1;
        }
        return;
    }
    
    method void clear() {
        var int x2; var int y2;
        if (~alive) { return; }
        
        let x2 = x + 31;
        let y2 = y + 31;
        
        // Validación estricta
        if (x < 0) { return; }
        if (y < 0) { return; }
        if (x2 > 511) { return; }
        if (y2 > 255) { return; }
        if (x > x2) { return; }
        if (y > y2) { return; }
        
        do Screen.setColor(false);
        do Screen.drawRectangle(x, y, x2, y2);
        return;
    }
    
    method void moveX(int dx) {
        do clear();
        let x = x + dx;
        do draw();
        return;
    }
    
    method void moveDown(int dy) {
        do clear();
        let y = y + dy;
        do draw();
        return;
    }
    
    method int leftX()  { return x; }
    method int rightX() { return x + 31; }
    method int topY()      { return y; }
    method int bottomY()   { return y + 31; }
    
    method void kill() {
        var int x2, y2;
        let x2 = x + 31;
        let y2 = y + 31;
        
        // Validar antes de animar
        if ((x < 0) | (y < 0) | (x2 > 511) | (y2 > 255)) {
            let alive = false;
            return;
        }
        
        // Animación de explosión: parpadeo rápido
        do Screen.setColor(false);
        do Screen.drawRectangle(x, y, x2, y2);
        do Sys.wait(20);
        do Screen.setColor(true);
        do Screen.drawRectangle(x, y, x2, y2);
        do Sys.wait(20);
        do Screen.setColor(false);
        do Screen.drawRectangle(x, y, x2, y2);
        
        let alive = false;
        return;
    }
    
    method boolean isAlive() { return alive; }
    method int getPoints() { return points; }
    
    /** NUEVO: Liberar memoria */
    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }
}